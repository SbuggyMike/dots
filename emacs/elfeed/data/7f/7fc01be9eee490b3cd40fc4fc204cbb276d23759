<p class=" text-justify drop-cap">What would Emacs be without Emacs Lisp? Elisp is there to help you with the bugbears that bedevil your daily life.</p><p class=" text-justify">And I think that’s great! Knowing elisp greatly expands your capabilities in Emacs. But, <em>but</em>, maybe you don’t know it — it’s yet another thing to learn. You may not have the time or the inclination. That’s especially true if you just want to customize or automate simple tasks.</p><p class=" text-justify">Not everyone who uses Emacs is a programmer. It has a wide audience, and that’s a really good thing, too. But that also ratchets up the difficulty if you have to pick up a programming language – possibly your first ever – to get simple things done. It’d be nice if you didn’t <em>have</em> to do that for simpler tasks. That’s where keyboard macros enter the frame. In Emacs they are very powerful, and as I’ll show you in a moment, more than capable of great feats of automation.</p><p class=" text-justify">Keyboard macros are misunderstood, and they can do an awful lot more than most people <em>think</em> they can do. They’re amazing for text editing. But they can do so much more than that. And the reason for this knowledge gap – even in people possessing much Emacs-fu – is that it’s hiding its capabilities in plain sight. That, and the siren song of elisp: it calls out to all of us, but you need not heed its call if you just want to do simple automation!</p><p class=" text-justify">Emacs’s keyboard macros can do pretty much everything <em>you</em> can do, except make human decisions about what to do next – but even here Emacs’s macro system has a few tricks up its sleeve.</p><p class=" text-justify"><em>Because</em> Emacs is able to record and play back nearly anything in a keyboard macro, you can leverage that to do things you wouldn’t normally think a keyboard macro <em>should</em> do, like:</p><dl><dt>Modifying your window layout</dt><dd><p class=" text-justify">Like your windows split a certain way, with certain buffers in certain places? Why not record a macro to do it for you. You can make it resize the windows, too.</p><p class=" text-justify">And if you need it, you can create several macros. Each one turns your window layout into something specialized and specific to your immediate needs. You can mix in some frame and tab action, too!</p><p class=" text-justify">Just make sure you start with a call to <code>C-x 1</code> to reset the windows back to one when you start the recording.</p><p class=" text-justify">Heck, you can even tell your macro to store the idealized window configuration in a register before it stops, if you’d rather recall your setup from one of those. (Window configurations are registers and they don’t persist between Emacs sessions.)</p></dd><dt>Visit files and Special Buffers</dt><dd><p class=" text-justify">Combined with custom window layouts, you can have Emacs open a particular file in each window. Open up a magit buffer, maybe <code>M-x calendar</code>, or something else entirely.</p></dd><dt>Speed up interactions with Org mode</dt><dd><p class=" text-justify">Do you regularly open up the Org mode agenda, only to apply filters and settings? Sure, you can <em>customize</em> it, but maybe you can get by with a macro.</p></dd><dt>Call up a Shell and execute commands in it</dt><dd><p class=" text-justify">Make it run <code>C-u M-x shell</code> (or <a class=" article-link" href="https://masteringemacs.org/article/complete-guide-mastering-eshell">Eshell</a>, or Vterm, or…) and run some commands that you frequently need to do.</p><p class=" text-justify">Or just call out to <code>M-x comint-run</code> or <code>M-x compile</code> for those one-off programs that you want to run. The possibilities are endless.</p></dd><dt>Search &amp; replace common terms</dt><dd><p class=" text-justify">If you find yourself having to bulk edit buffers, you can record a macro to do this for you. Maybe you have to make multiple passes, or you <em>actually</em> have to do some text editing with a macro. (Yes, it’s obviously great at that too.)</p><p class=" text-justify">Why not combine it with tools like <code>M-x rgrep</code> or Xref to find text matches across a large swathe of files, and use <code>M-g M-n</code> in a keyboard macro to bulk edit? Record the macro so it does one file, and then play it back and watch as it churns its way through the list of matches in your <code>*Grep*</code> buffer.</p></dd></dl><p class=" text-justify">OK, so those are just some of the things you can do with keyboard macros. And you know what, this approach will solve 80% of those annoying “I wish I knew elisp so I could solve this one problem” questions that frequently dog newer Emacs users. Window management is especially hard for beginners, particularly for those who come from IDEs with fixed layouts.</p><p class=" text-justify">What keeps people from using macros for serious work is the mistaken impression that macros are impermanent and go away when Emacs does. By default they <em>are</em> impermanent, but you can tell Emacs to persist them with a couple of commands. More on that in a second. That makes ’em far more useful for repeat use.</p><p class=" text-justify">But let me just quickly get the macro basics out of the way if you’re new to them.</p><h2 id="keyboard-macro-basics">Keyboard Macro Basics</h2><p class=" text-justify">If you’re new to them, here’s a very quick table to get you started. I’m just scratching the surface here. You can do a lot of crazy stuff with them. Just know that keyboard macro commands are named either <code>kmacro-</code> or they <em>contain</em> the word <code>kbd</code>. Many <code>kmacro-</code> commands are bound to the prefix key map <code>C-x C-k</code>. Explore it with <code>C-x C-k C-h</code>.</p><table class=" table"><thead><tr class="header"><th style="text-align: left;">Key Binding</th><th style="text-align: left;">Description</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>F3</code></td><td style="text-align: left;">Starts macro recording, or inserts counter value</td></tr><tr class="even"><td style="text-align: left;"><code>F4</code></td><td style="text-align: left;">Stops macro recording or plays last macro</td></tr><tr class="odd"><td style="text-align: left;"><code>C-x (</code> and <code>C-x )</code></td><td style="text-align: left;">Starts and stops macro recording</td></tr><tr class="even"><td style="text-align: left;"><code>C-x e</code></td><td style="text-align: left;">Plays last macro. Give prefix <em>arg</em> to repeat <em>arg</em> times</td></tr></tbody></table><p class=" text-justify">You can optionally give a prefix argument to <code>C-x e</code> or <code>F4</code> to make it repeat the macro that many times. Use <code>0</code> to tell Emacs to run the macro until it gets an error signal. A macro plays back until it encounters an error (end of buffer, end of matches in <code>*Grep*</code> if you advance with <code>M-g M-n</code>, and so on.) Watch out if you’re waving <code>C-g</code> around in a macro — it terminates the recording!</p><p class=" text-justify">If you call <code>F3</code> when you’re recording, it’ll insert a number from a counter and increment it. Use a universal arg (<code>C-u</code>) and it’ll repeat the last number without incrementing it. You can pass a numeric arg to <code>F3</code> to start the recording with a different number.</p><p class=" text-justify">This feature’s obviously great for numerating lists.</p><p class=" text-justify">But call <code>F3</code> with <code>C-u</code> twice and you’ll instead append to your last macro.</p><p class=" text-justify">You can do <em>way</em> more than this, but that’s the gist of it.</p><h2 id="naming-and-saving-keyboard-macros">Naming and Saving Keyboard Macros</h2><p class=" text-justify">In order to persist a macro you have to name it first. You do that with <code>C-x C-k n</code>, or <code>M-x kmacro-name-last-macro</code>. Recorded macros enter a macro ring – much like the kill, history or undo rings – but I recommend you name them if you think you’ll use them again later. Much easier than trying to find it again with <code>C-x C-k C-n</code> and <code>C-x C-k C-p</code>. Try running a named macro by invoking it with <code>M-x</code>.</p><p class=" text-justify">I strongly urge you to name your macros sensibly – ideally with a prefix. I use <code>mp-</code>.</p><p class=" text-justify">To persist it, you can ask Emacs to spit out an interactive function (a command) that is a like-for-like Elisp representation of the macro. To do this call <code>M-x insert-kbd-macro</code>. Emacs will ask for a named macro and insert a code-generated, interactive function at point. I recommend you insert it in your <code>init.el</code> file. It’s already named and evaluated at this point.</p><p class=" text-justify">One thing that annoys me, and maybe it annoys you too, is the inconsistent command naming. The logical answer is because the <code>kbd</code>-named commands predate the <code>kmacro-</code> ones by many years.</p><p class=" text-justify">The naming scheme is inconsistent and it lacks a key binding. So let’s fix that:</p><pre><code>(require 'kmacro)
(defalias 'kmacro-insert-macro 'insert-kbd-macro)
(define-key kmacro-keymap (kbd "I") #'kmacro-insert-macro)</code></pre><p class=" text-justify">Much better. Now you can find it again easily under <code>kmacro-</code> and it also has as its own key: <code>C-x C-k I</code>.</p><p class=" text-justify">There’s also a way to bind macros to keys (with <code>C-x C-k b</code>) or registers (with <code>C-x C-k x</code>) but they won’t persist. I recommend that you instead just call <code>M-x global-set-key</code> or <code>M-x local-set-key</code> if you want commands temporarily bound to keys, notwithstanding the register stuff, which is a great feature, if you are already familiar with it. But the global/local set key commands have the added advantage that you can bind keys to any command you like, and not just keyboard macro commands.</p><h2 id="interactive-keyboard-macros">Interactive Keyboard Macros</h2><p class=" text-justify">One neat, little feature is the ability to insert a <em>macro query</em> flag when you are recording a macro. A <em>macro query</em> is only triggered when you play it back. Emacs detects the query and pauses execution and cedes control back to you. To use it, type <code>C-x q</code> when you’re recording. There is no visual indicator when you type it, though.</p><p class=" text-justify">On playback you are then asked to pick from one of these options when the macro reaches the query flag:</p><table class=" table"><thead><tr class="header"><th style="text-align: left;">Query Key Binding</th><th style="text-align: left;">Description</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>y</code></td><td style="text-align: left;">Continues as normal</td></tr><tr class="even"><td style="text-align: left;"><code>n</code>, <code>DEL</code></td><td style="text-align: left;">Skips the rest of the macro</td></tr><tr class="odd"><td style="text-align: left;"><code>RET</code></td><td style="text-align: left;">Stops the macro entirely</td></tr><tr class="even"><td style="text-align: left;"><code>C-l</code></td><td style="text-align: left;">Recenters the screen</td></tr><tr class="odd"><td style="text-align: left;"><code>C-r</code></td><td style="text-align: left;">Enters recursive edit</td></tr><tr class="even"><td style="text-align: left;"><code>C-M-c</code></td><td style="text-align: left;">Exits recursive edit</td></tr></tbody></table><p class=" text-justify">That makes it excellent for what I call <em>interactive</em> macros that require user input. You can place the <em>macro query</em> anywhere you like — even in a prompt, like query replace regexp with <code>C-M-%</code>. You can even prefill the prompt; Emacs will remember that also.</p><p class=" text-justify">As the table shows, you’ve a number of options when control is ceded to you. I like <code>C-r</code> as it breaks out of the macro into a recursive edit session. Recursive editing is Emacs’s way of letting you pause something mid-way through, only to resume it later as though you were never gone. You can nest recursive editing levels more or less as much as you’d reasonably like.</p><p class=" text-justify">You can even run a whole new macro <em>inside</em> a recursive editing step. You can even run <em>the same one</em>! It’s macros all the way down.</p><p class=" text-justify">Emacs takes you back from whence you came when you back out of a recursive edit level with <code>C-M-c</code>. It’ll pick up where you left off when you entered it. You can tell you’re in a recurive editing step if you see <code>[ ]</code> in your mode line. <code>ESC ESC ESC</code> breaks out of all of them, if you just want to bail out now.</p><h2 id="lossage-step-editing-macros">Lossage &amp; Step-Editing Macros</h2><p class=" text-justify">When you type stuff Emacs keeps a record of it. Check it out: <code>C-h l</code>. You can turn parts of your <em>lossage</em> into a keyboard macro also with <code>C-x C-k l</code>. You can edit the buffer and use <code>C-c C-c</code> to commit the contents to a macro that you can then play back.</p><p class=" text-justify">You can also edit the last macro you have set with <code>C-x C-k C-e</code>. Occasionally useful if you’re doing something complex and you made a slight mistake. It works the same as the lossage interface. Heck, you can create brand new macros this way also, if you’re crazy enough.</p><p class=" text-justify">The <em>pièce de résistance</em> is the ability to step-wise edit a macro with <code>C-x C-k SPC</code>. Much like a debugger, you step through each playback step and you can decide what you want to do each step of the way.</p><p class=" text-justify">The step editor is loosely modeled on the <em>query replace</em> interfaces (like <code>M-%</code> and <code>C-M-%</code>) so if you have some familiarity with that, your knowledge applies here too.</p><table class=" table"><thead><tr class="header"><th style="text-align: left;">Step Edit Key</th><th style="text-align: left;">Description</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>C-h</code></td><td style="text-align: left;">Show inline help</td></tr><tr class="even"><td style="text-align: left;"><code>SPC</code>, <code>y</code></td><td style="text-align: left;">Act (apply) current command</td></tr><tr class="odd"><td style="text-align: left;"><code>n</code>, <code>d</code>, <code>C-d</code></td><td style="text-align: left;">Skip and delete current command</td></tr><tr class="even"><td style="text-align: left;"><code>TAB</code></td><td style="text-align: left;">Repeatedly act (apply) this command and all similar ones</td></tr><tr class="odd"><td style="text-align: left;"><code>!</code>, <code>c</code></td><td style="text-align: left;">Continue playing back the macro</td></tr><tr class="even"><td style="text-align: left;"><code>C-k</code></td><td style="text-align: left;">Skip and delete rest of macro</td></tr><tr class="odd"><td style="text-align: left;"><code>q</code>, <code>C-g</code></td><td style="text-align: left;">Cancel step editing</td></tr><tr class="even"><td style="text-align: left;"><code>u</code>, <code>U</code></td><td style="text-align: left;">Undo once / Undo all</td></tr><tr class="odd"><td style="text-align: left;"><code>i</code>, <code>r</code></td><td style="text-align: left;">Inserts / Replaces a series of commands until you enter <code>C-j</code></td></tr><tr class="even"><td style="text-align: left;"><code>I</code>, <code>R</code></td><td style="text-align: left;">Inserts / Replaces a single command</td></tr></tbody></table><p class=" text-justify">Stepping and editing is a supremely powerful feature that you should at least know about, even if you never use it. I find buffer editing a macro a bit easier to do as it’s easy to make a mistake step editing your macro, and before you know it you’re step editing your step edited macros. But the power of being able to step through and correct errors and insert or replace missing commands is undeniably powerful, and I’ve not even included all the commands you can use!</p><h2 id="conclusion">Conclusion</h2><p class=" text-justify">Macros are great. And you don’t need elisp to get started either. Being able to configure your window layout with a quick keyboard macro is actually a bit of a super power. If you want to do that in a way that is persistent and stable and <em>easily interchangeable</em> you don’t have many options beyond elisp; maybe the <code>frameset</code> library; and third-party packages.</p><p class=" text-justify">And that’s to say nothing, of course, of the ability of keyboard macros to edit text. They’re definitely amazing at that also. But I think it’s all too easy to <em>only</em> look at them in that light. And if you’re new or unfamiliar with Elisp then it’s an easy way to supercharge your Emacs by <em>recording how you want it done</em>.</p><p class=" text-justify">Oh, and believe me, I haven’t even <em>scratched</em> the surface of what you can do with keyboard macros in Emacs. So, if you do something cool with macros, I’d love to hear about it!</p>