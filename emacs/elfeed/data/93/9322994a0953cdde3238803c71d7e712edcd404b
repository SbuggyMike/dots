<p>Mickey from <a href="https://www.masteringemacs.org">Mastering Emacs</a> has posted an excellent summary of <a href="https://www.masteringemacs.org/article/running-shells-in-emacs-overview">shells &amp; emulators in Emacs</a>. The subject can be a little confusing—mostly centering around the difference between a shell and an emulator—so if you’ve ever been uncertain if you should be running <code>shell</code>, <code>term</code>, or <code>ansi-term</code> be sure to check out his post.</p>
<p>If you’ve used any of those you know that they all have limitations. Mickey’s post tells you how to work around some of those limitations and how to do things like change the default shell or stop the duplicate echoing of shell input. He also discusses Vterm and Eshell.</p>
<p>Mickey’s first recommendation is to consider whether you need a shell at all. Emacs, after all, has Dired for file manipulation, Magit for Git interaction, built-in network utilities, and the <code>compile</code> function to compile and test your code. Even as a long time command line guy, I’ve found that I rarely need to invoke a shell these days.</p>
<p>If you <i>do</i> need a shell, Mickey recommends either <code>shell</code> or <code>eshell</code>. These have the advantage that you’re working in an Emacs buffer so you have all the usual Emacs capabilities available for working with the text. I like Vterm because it gives a much better emulation than the others but as Mickey says, you won’t have the valuable Emacs features available for working with the buffer.</p>
<p>Finally, there’s a long list of comments that are also worth reading. Especially Ramin Honary’s comment on using <a href="https://elpa.gnu.org/packages/coterm.html">coterm</a> for better terminal emulation. As always with Mickey’s posts, this one is very much worth reading</p>