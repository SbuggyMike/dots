<p class=" text-justify drop-cap">Long ago – so long, in fact, that there’s neither a <code>NEWS</code> nor a source control commit entry for it – Emacs introduced <code>completing-read</code>. <code>completing-read</code>, if you’re not familiar with it, prompts for input from the user and proffers completions. In other words, it’s the function responsible for Emacs’s <em>minibuffer completion</em>. It can do more than that; but that’s a quick summary.</p><p class=" text-justify">Ordinarily, that’d be the end of that, right?</p><p class=" text-justify">And for the longest time, that <em>was</em> the end of it. Historically, Emacs’s completer was rather simple – with little more than basic word completion – and not much better than what you’d get in your garden-variety shell. So intrepid Emacs hackers wrote their own completion functions that went above and beyond what <code>completing-read</code> could do, and that gave us a litany of packages that tried to fix the rather tedious default completer.</p><p class=" text-justify">I can’t even begin to list all of them. I won’t even try to list all the ones <em>in Emacs</em>. A storied example of a completion framework that has been around since the 90s that survives and thrives to this day is <a class=" article-link" href="https://www.masteringemacs.org/article/introduction-to-ido-mode">IDO Mode</a>.</p><p class=" text-justify">IDO holds a special place in my heart. When I started using Emacs I used the default completer because I did not know any better. Imagine my surprise when I cottoned on to IDO mode! It was a large productivity boost and it gave me a different – as I was still rather new to Emacs – insight into Emacs and how it works and what you can do with it. Here’s an off-hand command that <em>replaces the entire prompt and completion system</em>. There’s a reason the second article I ever wrote on Mastering Emacs was about IDO.</p><p class=" text-justify">But IDO is not perfect. It works by hook or by crook; but imperfectly, too, as IDO has to patch parts of Emacs to make it work. That causes friction as you’ll need separate completion functions – <code>ido-find-file</code> vs <code>find-file</code>, for example – for each completion category you want IDO to work with.</p><p class=" text-justify">Luckily, over the years, the Emacs maintainers made a concerted effort to make completion in Emacs more accessible and extensible.</p><p class=" text-justify">If you long ago abandoned the default completer – or if you have never tried customizing it – you should give it another shot. Here’s why:</p><dl><dt>Category-aware Completion</dt><dd><p class=" text-justify">What you’re looking for is as important as the <em>type</em> of what you’re looking for. How you complete files with <code>C-x C-f</code> is altogether different than what you’d use when you complete buffer names with <code>C-x b</code> or symbols with <code>M-x</code>.</p><p class=" text-justify">Emacs is now aware of the type of completion you’re doing. That means you can tailor your completion styles by category.</p></dd><dt>Multiple Styles of Completion</dt><dd><p class=" text-justify">Completion style is a matter of personal preference. It’s something you use all day, every day. And it’s something that you develop an intuition for. So if Emacs ever were to change the defaults – and they’ve cautiously done so over the last decade and a half – you’d want the ability to <em>revert</em> those changes or, indeed, adopt other completion styles you didn’t use before.</p><p class=" text-justify">Combined with category-aware completion, you can tell Emacs that you want flex-style matching (a style of matching such that <code>bk</code> matches <code>book</code>) for <code>C-x C-f</code> but initials matching (<code>ttl</code> matches <code>toggle-truncate-lines</code>) for <code>M-x</code>.</p><p class=" text-justify">And this is again something that package authors can build on; both by adding more categories, and by extending the type of completion styles Emacs supports.</p></dd><dt>Cycling through completion alternatives</dt><dd><p class=" text-justify">Instead of seizing up and asking for more text when there are two or more completion candidates, you can tell Emacs to cycle through them instead.</p></dd><dt>Incremental Completion</dt><dd><p class=" text-justify">Yep. Emacs has had <code>M-x icomplete-mode</code> for an eternity, but it’s seen a number of improvements over the years.</p><p class=" text-justify">Incremental completion supplants the RSI-inducing <code>TAB</code>-style completion with a candidate list that narrows visually as you type.</p><p class=" text-justify"><code>M-x fido-mode</code> – called Fake IDO, as it’s a facsimile of IDO – is built on top of it, and is new to Emacs 28. But more on FIDO later.</p></dd><dt>Annotations</dt><dd><p class=" text-justify">Instead of just showing the completion candidates themselves, Emacs has greatly improved the way you attach metadata to them. Package authors can now annotate the completion matches with additional information, like showing a key binding belonging to a symbol in <code>M-x</code>.</p></dd><dt>Interoperable Completion Tables</dt><dd><p class=" text-justify">Though it does not directly benefit minibuffer completion much, I would be remiss if I did not at least mention it here, as it’s a core part of Emacs’s plan to open up the completion machinery to one and all.</p><p class=" text-justify">One common issue in Emacs was the lack of compatibility between completion tables, the bit responsible for sourcing completion candidates. If you wrote code that generates completion data, you’d have to pick a completion tool to expose it through. So if you really liked Helm, you might write some glue code to make it work well with Helm. And if someone else comes along later and wants to make it work with IDO, they’d have to do all manner of nasty deeds to yank the raw data and feed it into IDO.</p><p class=" text-justify">That’s luckily a thing of the past.</p><p class=" text-justify">Years ago I wrote about <a class=" article-link" href="https://www.masteringemacs.org/article/pcomplete-context-sensitive-completion-emacs">PComplete, EShell’s completion framework</a> and it is one example of a standalone completer: it has a number of sources that generate completion data, and a completion layer designed to work specifically with <code>M-x eshell</code> and <code>M-x shell</code>. If you wanted that completion data to show up in Helm — you’d have to roll up your sleeves and write some glue code.</p><p class=" text-justify">Today, it works seamlessly with any completion framework you use, thanks to this consolidation – including the default minibuffer completion system, if you so desire.</p></dd></dl><p class=" text-justify">OK, so those are the major improvements. Let’s look at how you can take advantage of them.</p><h2 id="customizing-minibuffer-completion">Customizing Minibuffer Completion</h2><p class=" text-justify">First things first. Completion intersects with a large swathe of packages and settings in Emacs. Make sure you disable those first. I recommend you test the completion settings in a clean-room environment. Run <code>emacs -q</code> and experiment there instead.</p><p class=" text-justify">I also want to make it clear that completion is still a planet-sized ball of yarn. Completion systems are messy – <em>period</em>. Doubly so in Emacs, as it still supports a wide gamut of third-party and native packages spanning <em>decades</em>.</p><h3 id="minibuffer-key-bindings">Minibuffer Key Bindings</h3><p class=" text-justify">A quick key binding refresher is in order, perhaps. There’s only a few, but perhaps more than you know about.</p><table class=" table"><colgroup><col style="width: 23%;" /><col style="width: 25%;" /></colgroup><tbody><tr class="odd"><td style="text-align: left;"><strong>Key Binding</strong></td><td style="text-align: left;"><strong>Description</strong></td></tr><tr class="even"><td style="text-align: left;"><code>RET</code>, <code>C-j</code></td><td style="text-align: left;">Maybe complete, and maybe exit</td></tr><tr class="odd"><td style="text-align: left;"><code>TAB</code></td><td style="text-align: left;">Complete</td></tr><tr class="even"><td style="text-align: left;"><code>SPC</code></td><td style="text-align: left;">Complete Word</td></tr><tr class="odd"><td style="text-align: left;"><code>C-g</code></td><td style="text-align: left;">Abort</td></tr><tr class="even"><td style="text-align: left;"><code>M-v</code></td><td style="text-align: left;">Switch to <code>*Completions*</code> window</td></tr><tr class="odd"><td style="text-align: left;"><code>TAB</code> <code>TAB</code> <em>or</em> <code>?</code></td><td style="text-align: left;">Show <code>*Completions*</code> window</td></tr></tbody></table><p class=" text-justify">Some of the key bindings change slightly depending on context. You cannot complete invalid symbols in <code>M-x</code>, for example, as that wouldn’t make sense. But when you switch buffers with <code>C-x b</code> you <em>can</em> — maybe you wanted to create a new one. That means <code>RET</code> may complete or exit depending on what you’re asking Emacs to do.</p><p class=" text-justify"><code>SPC</code> is useful to know about, and you’ve probably discovered that one by accident yourself. It completes to the next “word”. How useful word completion is comes down to the completion styles you’re using. More on those in a bit.</p><p class=" text-justify">You can double-tap <code>TAB</code>, or type <code>?</code>, to show the <code>*Completions*</code> window. Whether double-tapping works depends on <code>completion-auto-help</code>. But I’ll rate the odds are near zero that you or anyone else has ever bothered changing it!</p><p class=" text-justify"><code>M-v</code> is one you probably don’t know about. It’s also bound to the harder to type <code>M-g M-c</code>. Neither are particularly logical, although the <code>M-g</code> prefix keymap does have keys that jump to things, so that’s probably why.</p><p class=" text-justify">Anyway, it reveals and puts the point in the <code>*Completions*</code> window. You can then navigate in it:</p><table class=" table"><colgroup><col style="width: 22%;" /><col style="width: 22%;" /></colgroup><tbody><tr class="odd"><td style="text-align: left;"><strong>Key Binding</strong></td><td style="text-align: left;"><strong>Description</strong></td></tr><tr class="even"><td style="text-align: left;"><p class=" text-justify"><code>n</code>, <code>TAB</code></p><p class=" text-justify"><code>p</code>, <code>S-TAB</code></p></td><td style="text-align: left;">Forward and backward match</td></tr><tr class="odd"><td style="text-align: left;"><code>z</code></td><td style="text-align: left;">Kill buffer</td></tr><tr class="even"><td style="text-align: left;"><code>RET</code></td><td style="text-align: left;">Select match</td></tr><tr class="odd"><td style="text-align: left;"><code>M-g M-c</code></td><td style="text-align: left;">Back to minibuffer</td></tr></tbody></table><p class=" text-justify">Whether this is of use to you depends greatly on whether you prefer sifting through the <code>*Completions*</code> window or not. Note that you have to use <code>z</code> to kill the buffer and not <code>q</code> like in most other transient buffers.</p><h4 id="customizing-completions">Customizing <code>*Completions*</code></h4><p class=" text-justify">There’s a couple of customizable options that affect <code>*Completions*</code>. The first is <code>completions-format</code>. It controls how matches are ordered: horizontal, vertical, or one column.</p><p class=" text-justify">The other is <code>completions-annotations</code>, a face for the annotations (if any).</p><h3 id="changing-the-default-completion-mechanism">Changing the default Completion Mechanism</h3><p class=" text-justify">IDO and friends had to assert themselves using hooks and by reinventing the <code>completing-read</code> function. But Emacs 24.1 introduced <code>completing-read-function</code> that hollowed out <code>completing-read</code> and made it a proxy for any function you wanted, provided you mirrored <code>completing-read</code>’s function arguments. What was once the default completer is now named, unsurprisingly, <code>completing-read-default</code>.</p><p class=" text-justify">Emacs has a number of elementary functions responsible for <em>reading</em> an answer from the user. <code>read-buffer</code> for buffers; <code>read-file-name</code> for file names; and so on. They were ‘hollowed out’, so to speak, long before <code>completing-read</code> was and they behave in much the same way: you can tap into how Emacs reads specific input from a user and alter it. I won’t be talking about them any more as I’d rather look at completion as a whole. And it’s in any event filtered through <code>completing-read</code> more often than not, anyway.</p><p class=" text-justify">And anyway, if you’re using a ‘modern’ third-party completion framework, you can see if it hooks into these systems with <code>C-h v</code>: try it on <code>completing-read-function</code>, <code>read-file-name-function</code>. Some won’t show up here: <code>icomplete</code> being one of them (more on why later); and IDO being another.</p><p class=" text-justify">Newer completion frameworks are more likely to follow Emacs’s best practices like setting <code>completion-read-function</code>, and maybe the reader functions, but not all of them will. That does not necessarily make them worse than those that do set it.</p><h3 id="completion-categories">Completion Categories</h3><p class=" text-justify">Completing stuff is contextual, and as I alluded to earlier, what you want when you’re completing a file is not necessarily how you’d look up a symbol with <code>M-x</code> or an Xref reference with <code>M-?</code>. Emacs solves that problem by letting you pick completion styles for each category, if you so choose.</p><p class=" text-justify">What they are, and what they do, is a bit loosey-goosey: it’s up to the provider of completion information to tell Emacs what category it belongs to. Nevertheless, <code>completion-category-defaults</code> offers up a selection of the most common ones:</p><blockquote><p class=" text-justify"><code>email</code>, <code>buffer</code>, <code>unicode-name</code>, <code>project-file</code>, <code>xref-location</code>, <code>info-menu</code>, and <code>symbol-help</code>.</p></blockquote><p class=" text-justify">You don’t have to worry about adding, changing or removing categories at all.</p><p class=" text-justify">What you do care about is how Emacs applies completion styles. Indeed, what you’re completing may exist outside the boundaries of the categories you see above — but more on how that’s resolved below.</p><h3 id="cycling-through-candidates">Cycling through Candidates</h3><p class=" text-justify">It’s disabled by default, so most don’t know about this feature, but instead of insisting that you complete more text when you <code>TAB</code> or <code>SPC</code>, you can instead tell Emacs to <em>cycle</em> through the remaining candidates.</p><p class=" text-justify">That’s obviously useful in <em>some</em> instances, and you can control when it should take effect by editing <code>completion-cycle-threshold</code>. That variable affects cycle thresholds at a <em>global</em> level. You can also configure it per-category, as you’ll see below.</p><p class=" text-justify">When you set <code>completion-cycle-threshold</code> to <code>t</code> you are effectively disabling the usual <code>TAB</code> mechanism in favor of one that cycles through all the candidates. That is probably undesirable if you have a large number of matches!</p><p class=" text-justify">So, if you instead give it a number, then it’ll only kick in when there are fewer than that number of candidate matches available. Set it to <code>nil</code> and you disable it.</p><p class=" text-justify">It’s definitely worth experimenting with, particularly when you have only a few candidate matches left to filter against. Try experimenting with small values like 2, 3, or 5.</p><h3 id="annotations">Annotations</h3><p class=" text-justify">Though it’s not that widely used yet in native Emacs, it does come with annotations in Emacs 28.</p><p class=" text-justify"><code>suggest-key-bindings</code> shows the key bindings, if any, belonging to each symbol in <code>M-x</code>. It’s enabled by default. And the variable <code>completions-detailed</code> controls whether Emacs should include the docstring description for completion candidates in commands like <code>describe-function</code>. I think it’s super handy. so I’ve enabled it.</p><h3 id="changing-completion-styles">Changing Completion Styles</h3><p class=" text-justify">This is perhaps one of the more important things you can change about Emacs’s completer.</p><p class=" text-justify">The first one is one you’re not interested in editing directly unless you’re writing your own completion routine. But it’s good to know about because it’s where the Emacs draws the style definitions from. So if you crack open <code>completion-styles-alist</code> you’ll see the <code>NAME</code>; a docstring describing how that completion style works; and the names of the functions that do all the work.</p><p class=" text-justify">In my Emacs, there’s a <code>helm</code> style (because I also use Helm.) It replicates Helm’s multi-completion style so you can use it outside Helm — how nice of the Helm team!</p><p class=" text-justify">Other styles include <code>emacs21</code>, <code>emacs22</code>, <code>basic</code>, <code>flex</code>, <code>partial-completion</code>, and <code>initials</code>. Your Emacs may have more or less. I recommend you experiment and look yourself.</p><p class=" text-justify">The variable <code>completion-category-defaults</code> is “internal” and controls the default completion styles for each <em>category</em>. You can override it by editing <code>completion-category-overrides</code>.</p><p class=" text-justify">If you’re not an elisp maven, I recommend you use <code>M-x customize-option</code> to experiment as it supports the nested association list structures required for some of the variables to work. However, note that due to what I think is an oversight, the list of valid categories is strictly less than what’s available to you.</p><p class=" text-justify">You can control category and the list of styles you want to use. The list of styles is <strong>ordered</strong>: Emacs will apply the first completer, then the second, and so on. So you’ll have to experiment with the ordering to find one you like.</p><p class=" text-justify">You can also control whether Emacs should cycle candidates by category.</p><p class=" text-justify">Here’s an example where I enable <code>initials</code> and <code>flex</code> for the <code>buffer</code> category. It will cycle matches if there are fewer than three:</p><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">setq</span> completion-category-overrides
  '((buffer
    (styles initials flex)
    (cycle . <span class="dv">3</span>))))</code></pre><p class=" text-justify"><em>Finally</em>, that leaves <code>completion-styles</code>. It hosts a list of “catch-all” completers you want <strong>everywhere</strong>. And when I say everywhere, I mean <em>everywhere</em>. You see, Emacs checks the completion styles in this order:</p><ol type="1"><li>First it checks the category defaults in <code>completion-category-defaults</code>.</li><li>Next, it checks if there are any overrides in <code>completion-category-overrides</code>. If there are, it uses them instead of #1.</li><li>Then, it merges the styles from #1 or #2 with <code>completion-styles</code>. The category-specific styles in #1 or #2 take precedence over the styles in <code>completion-styles</code>.</li></ol><p class=" text-justify">If you’re experimenting with completion styles just modify <code>completion-styles</code>. It is my preferred suggestion if you don’t need category-specific overrides. You can always migrate them to categories later.</p><h3 id="case-sensitivity-matching">Case Sensitivity Matching</h3><p class=" text-justify">Emacs cleverly turns off case-sensitive buffer and file matching if you’re on Windows. On platforms with case-sensitive file systems, it’s enabled by default. But that <em>does</em> mean you have to reach for the shift key when you want to complete case-sensitive matches. Not fun.</p><p class=" text-justify">So if that bothers you, you can force Emacs to ignore casing:</p><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">setq</span> read-buffer-completion-ignore-case <span class="kw">t</span>)
(<span class="kw">setq</span> read-file-name-completion-ignore-case <span class="kw">t</span>)</code></pre><h3 id="ignoring-file-names-and-paths">Ignoring File Names and Paths</h3><p class=" text-justify">There are plenty of useless files and directories that you don’t want to match against. You can tell Emacs to not show them by default by customizing <code>completion-ignored-extensions</code>. It comes with a healthy list by default.</p><p class=" text-justify">Directories must end with a <code>/</code> or Emacs won’t treat it as a directory, though!</p><p class=" text-justify">It’s got a decent list of defaults already baked in, but I’m sure you can think of more things to add to it:</p><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(add-to-list 'completion-ignored-extensions <span class="st">".bin"</span>)
(add-to-list 'completion-ignored-extensions <span class="st">"some-dir/"</span>)</code></pre><p class=" text-justify">Emacs will <em>still</em> match against ignored “extensions” if there are no other plausible matches, so you’ll never find yourself in a position where you cannot possibly match them.</p><h2 id="environment-variable-completion">Environment Variable Completion</h2><p class=" text-justify">One little-known feature of the default completer is that you can jump to the values of environment variables. Try inputting <code>$HOME</code> (or another of your choice) in <code>C-x C-f</code>. Windows users also benefit from this, but the syntax is the same as Linux.</p><h2 id="icomplete">Icomplete</h2><p class=" text-justify">Icomplete has been in Emacs for a long while. If you’re not familiar with it, it adds “incremental” completion much in the style of Helm, IDO, and most third-party completers. It does so – contrary to all the talk I just did about <code>completing-read-function</code> earlier – by augmenting the completion experience of the <em>default</em> Emacs completion system using hooks.</p><p class=" text-justify">That means you benefit, more or less, from many of the customizations I just talked about. So if you <em>do</em> use Icomplete, you should definitely customize the previously mentioned variables.</p><p class=" text-justify">Icomplete is still a little bit different than the likes of IDO and most third-party completers. It still carries some of the <code>TAB</code>-style completion mentality that the default completer also uses.</p><p class=" text-justify">Icomplete also has a useful set of customizable options – too many to repeat here – but they include faces for matches, how long you have to wait before completion candidates appear after typing, and more. If the timings seem “off” to you, you should tweak them. Type <code>M-x customize-group icomplete</code> to customize Icomplete.</p><p class=" text-justify">Pressing <code>RET</code> won’t pick the selected option; you’re still expected to fully complete in completion prompts that require you to do so (notably <code>M-x</code>). For things like file and buffer prompts, <code>RET</code> will instead just create a blank file or buffer.</p><p class=" text-justify">Icomplete has its own set of key bindings <em>in addition to</em> the minibuffer completion key bindings I listed above:</p><table class=" table"><colgroup><col style="width: 22%;" /><col style="width: 23%;" /></colgroup><tbody><tr class="odd"><td style="text-align: left;"><strong>Key Binding</strong></td><td style="text-align: left;"><strong>Description</strong></td></tr><tr class="even"><td style="text-align: left;"><code>M-TAB</code></td><td style="text-align: left;">Force completion</td></tr><tr class="odd"><td style="text-align: left;"><code>C-j</code></td><td style="text-align: left;">Force completion and exit</td></tr><tr class="even"><td style="text-align: left;"><code>C-,</code>, <code>C-.</code></td><td style="text-align: left;">Forward and backward selection</td></tr></tbody></table><p class=" text-justify">Force completion is an Icomplete term. Forcing a completion takes the text of the selected candidate and puts that in your prompt. <code>M-TAB</code> is <code>Alt+Tab</code> which is a rather common key binding to switch windows in most window managers. So you probably won’t be able to use that one without rebinding it.</p><p class=" text-justify">But the one you’re more likely to care about anyway is <code>C-j</code>: it picks the selected match and exits the completion. Combine it with <code>C-,</code> and <code>C-.</code> and you can move forward or backward through the candidate list.</p><p class=" text-justify">If you think <code>C-j</code> behaves the way you’d expect <code>RET</code> to behave then you can you of course rebind it. But in that case, you’re better off using FIDO Mode.</p><h2 id="fido-fake-ido">FIDO: Fake Ido</h2><p class=" text-justify">Built on top of Icomplete, FIDO is an attempt to bring some of the features of IDO mode to Icomplete. It’s not entirely successful; but it does make a reasonable attempt at it.</p><p class=" text-justify">I have written about <a class=" article-link" href="https://masteringemacs.org/article/introduction-to-ido-mode">IDO Mode</a> before, so I will not retread it here. But I’ll summarize why people use IDO: file finding with IDO is exceptionally ergonomic, and it has a large collection of useful key bindings. It also has excellent flex matching, which inspired Emacs’s <code>flex</code> completion style.</p><p class=" text-justify">FIDO mode builds on top of Icomplete’s key bindings which, in turn, is built on top of Emacs’s default completion key bindings.</p><table class=" table"><colgroup><col style="width: 22%;" /><col style="width: 23%;" /></colgroup><tbody><tr class="odd"><td style="text-align: left;"><strong>Key Binding</strong></td><td style="text-align: left;"><strong>Description</strong></td></tr><tr class="even"><td style="text-align: left;"><code>C-k</code></td><td style="text-align: left;">Kill buffer or delete file</td></tr><tr class="odd"><td style="text-align: left;"><code>M-j</code></td><td style="text-align: left;">Like <code>C-j</code> in IDO. Uses the prompt text.</td></tr><tr class="even"><td style="text-align: left;"><code>C-s</code>, <code>C-r</code></td><td style="text-align: left;">Forward or backward selection</td></tr><tr class="odd"><td style="text-align: left;"><code>DEL</code></td><td style="text-align: left;">Maybe go up a directory (if it is a file completion) otherwise delete backward char</td></tr><tr class="even"><td style="text-align: left;"><code>RET</code></td><td style="text-align: left;">Pick selected candidate</td></tr></tbody></table><p class=" text-justify">If you don’t use IDO, then I think FIDO a great upgrade over Icomplete if you don’t like TAB-style completion. It all but eliminates the percussive <em>tab, tab, tab</em> routine you inevitably find yourself in as you try to winnow down your candidate matches to the one you like.</p><p class=" text-justify">But if you <em>do</em> use IDO, it’s not an upgrade at all for file or buffer completion. It definitely <em>is</em> for other types of completion if you like IDO-style completion there, though.</p><p class=" text-justify">What is more interesting is that it is built on top of Icomplete. Many of its features come from tweaking Icomplete and the default completion styles to mirror those found in IDO — so that’s a massive win for the extensibility of Emacs’s default completer.</p><h2 id="vertical-completion">Vertical Completion</h2><p class=" text-justify">Quite a few people prefer vertical completion as opposed to the horizontal style of organizing candidates. So if you like vertical completion, then you should know that Emacs 28 introduced <code>M-x fido-vertical-mode</code> and <code>M-x icomplete-vertical-mode</code>.</p><p class=" text-justify">You can configure how many vertical candidates to show by customizing <code>max-mini-window-height</code>. But beware: this affects all commands that display text in the minibuffer.</p><h2 id="conclusion">Conclusion</h2><p class=" text-justify">After a decade of slow and steady improvements, Emacs’s default completer is more advanced and capable than it seems. I imagine that, over time, we’ll see more completion frameworks built on top of it.</p><p class=" text-justify">If you ditched the default completer, then maybe it’s time you give the default completion system another try. Perhaps it does what you need?</p><p class=" text-justify">And if not, then why not use multiple completion systems? I do. Each category of completion has its own set of challenges and requirements, and perhaps we ask for too much when we expect one completion framework to get everything right, for everyone, all the time.</p><p class=" text-justify">I really like Helm for its bountiful supply of completion sources replete with topical actions. It’s super fast, comes with both caching and lazy filtering, and it is great for candidate matches where you need more space than you could reasonably fit in the minibuffer. I also use IDO, as I like how it does file and buffer matching.</p><p class=" text-justify">There’s no harm in picking and choosing what you like.</p><p class=" text-justify">It’s Emacs, after all.</p>