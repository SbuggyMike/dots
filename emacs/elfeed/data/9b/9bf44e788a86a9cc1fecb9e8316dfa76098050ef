<p class=" text-justify drop-cap">Filtering long lists of output on the command line usually involves taking the list of items – maybe the output of <code>ls</code>, <code>git</code> or <code>find</code> – and doing something with it. If you’re lucky you can mechanically filter the list with pipes and <code>grep</code>. If you’re unlucky and you can’t think of a heuristic, you’ll have to sift through the output with a pager like <code>less</code> and remember the items you want to keep.</p><figure>
   <img alt="fzf filtering output from apt-cache search intended for apt-get" class=" center-block" src="https://www.masteringemacs.org/static/uploads/fzf.png" />
<code>fzf</code> filtering output from <code>apt-cache search</code> intended for <code>apt-get</code>
</figure><p class=" text-justify">Typically you do this because you want to cherry pick a subset of the items and feed them into another command, like <code>rm</code>, <code>cat</code> or <code>apt-get</code> as the picture above illustrates.</p><p class=" text-justify">But the manual way is tedious and slow. And that’s the problem <a class=" article-link" href="https://github.com/junegunn/fzf">fzf</a> tries to solve. The premise is simple: you feed it (via stdin) a list of items, and it displays a curses-like window where you can “fuzzy find” and select the items you care about. It’s designed to slot into command substitutions and pipes — like an interactive <code>grep</code>.</p><p class=" text-justify">So that got me thinking. There’s no reason why you can’t use Emacs to do this instead of <code>fzf</code>! Emacs has better fuzzy finding and it’s the text editor you’re already using, so why not use Emacs?</p><p class=" text-justify">Another reason to ditch <code>fzf</code> is that you might be using <a class=" article-link" href="https://masteringemacs.org/article/running-shells-in-emacs-overview">a shell and not a terminal emulator in Emacs</a>. It’s not impossible to run curses apps in <code>shell-mode</code>, but it is harder.</p><h2 id="ezf-emacs-fuzzy-finder">EZF: Emacs Fuzzy Finder</h2><figure>
   <img alt="Fuzzy matching with Helm" class=" center-block" src="https://www.masteringemacs.org/static/uploads/ezf-example-optimised.gif" />
<code>ezf</code> filtering output from <code>apt-cache</code> before passing it back to the shell
</figure><p class=" text-justify">So the game plan is simple:</p><dl><dt>Build a shell script</dt><dd><p class=" text-justify">This is the shell-facing part that we feed into pipes and command substitution sub-shells.</p><p class=" text-justify">It must talk to <code>emacsclient</code>, the client in the Emacs client-server duo. That way it’ll run in your existing Emacs instance and it won’t interrupt your workflow if you also use – as you well should! – Emacs as your shell or terminal emulator.</p></dd><dt>Write some Elisp glue code</dt><dd><p class=" text-justify">We’ll need a few functions capable of letting you filter and select the match candidates you like. Luckily this is generally very easy.</p></dd><dt>Return the picked candidates</dt><dd><p class=" text-justify">After matching and selecting the candidates we want to keep, we must return them from whence they came. We’ll need to be mindful of annoying bagatelles like proper quoting.</p></dd><dt>Make it easy to extend</dt><dd><p class=" text-justify">It should be easy to extend or modify to suit individual tastes.</p><p class=" text-justify">We’ll add a few command switches to <code>ezf</code> to highlight how easy it is to pass customizable switches through bash into Emacs.</p></dd></dl><h3 id="sending-to-emacss-standard-input">Sending to Emacs’s standard input</h3><p class=" text-justify">Let’s start with the shell script. I’ve done it in <code>bash</code>. There’s a number of little gotchas and workarounds required for this to work well. So the script’s freighted with one or two annoying hacks.</p><p class=" text-justify">Chiefly, it’s not possible to ask <code>emacsclient</code> or even <code>emacs</code> to read directly from a file descriptor device. So process substitution with <code>&lt;(ls ...)</code> is out. I don’t know why, as Emacs is absolutely 100% capable of <em>doing</em> it inside Emacs. So I’m chalking it up to oversight.</p><p class=" text-justify">That means we have to work around that problem with real files. I’m using <code>mktemp</code> to <code>cat</code> standard input to a temporary file. To avoid clobbering your <code>tmpfs</code> with junk files, there’s a <code>trap</code> to clean up when the script exits.</p><p class=" text-justify">Now all we need to do is add a little command argument parsing: I want <code>-c</code> to let us choose the completion tool to invoke in Emacs; and <code>-f</code> is there to pick the field offset to return. The latter is particularly useful if you have a line of text and you want just the first word, for example.</p><p class=" text-justify">After that, there’s a little bit of house keeping in case you exit out of the selection process without picking anything. Oh, when you tell <code>emacsclient</code> to evaluate elisp it’ll use <code>prin1</code> to emit the representation of the Lisp object to standard output, and that forces quote symbols around strings, even if we don’t really want that. Sieving the output from Emacs through a pipe to <code>xargs</code> cunningly strips the quotes.</p><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">#!/usr/bin/env bash</span>
<span class="kw">set</span> <span class="kw">-o</span> nounset -o errexit -o pipefail

<span class="ot">field=</span>nil
<span class="co"># the elisp function to use for completing read</span>
<span class="ot">candidate_fn=</span>ezf-default
<span class="kw">while</span> <span class="kw">getopts</span> c:f: OPT<span class="kw">;</span> <span class="kw">do</span>
    <span class="kw">case</span> <span class="ot">$OPT</span><span class="kw"> in</span>
        c<span class="kw">)</span>
            <span class="ot">candidate_fn=$OPTARG</span>
            <span class="kw">;;</span>
        f<span class="kw">)</span>
            <span class="ot">field=$OPTARG</span>
            <span class="kw">;;</span>
        *<span class="kw">)</span>
            <span class="kw">echo</span> <span class="st">"usage: </span><span class="ot">${0##</span>*/<span class="ot">}</span><span class="st"> [-f field] [-c candidate-fn]"</span>
            <span class="kw">exit</span> 2
    <span class="kw">esac</span>
<span class="kw">done</span>
<span class="kw">shift</span> <span class="ot">$((</span> OPTIND - 1 <span class="ot">))</span>
<span class="ot">OPTIND=</span>1

<span class="ot">ezftmp=</span><span class="st">"</span><span class="ot">$(</span><span class="kw">mktemp</span><span class="ot">)</span><span class="st">"</span>
<span class="kw">trap</span> <span class="st">'rm -f -- "$ezftmp"'</span> EXIT
<span class="kw">&gt;</span> <span class="st">"</span><span class="ot">$ezftmp</span><span class="st">"</span> <span class="kw">cat</span> -
<span class="co"># xargs is there to strip the "" from the beginning and end of the output from Emacs.</span>
<span class="ot">selection=$(</span><span class="kw">emacsclient</span> -e <span class="st">"(ezf </span><span class="dt">\"</span><span class="ot">$ezftmp</span><span class="dt">\"</span><span class="st"> </span><span class="ot">$field</span><span class="st"> #'</span><span class="ot">$candidate_fn</span><span class="st">)"</span> <span class="kw">|</span> <span class="kw">xargs</span><span class="ot">)</span>
<span class="kw">if [[</span> <span class="st">"</span><span class="ot">$selection</span><span class="st">"</span> <span class="ot">==</span> <span class="st">"nil"</span><span class="kw"> ]]</span>; <span class="kw">then</span>
    <span class="kw">exit</span> 1
<span class="kw">else</span>
   <span class="kw">echo</span> <span class="st">"</span><span class="ot">$selection</span><span class="st">"</span>
<span class="kw">fi</span></code></pre><p class=" text-justify">I’ve named it <code>ezf.sh</code> (symlinked to <code>ezf</code>) so all you need to do is put it somewhere on your <code>PATH</code>.</p><h3 id="filtering-in-emacs">Filtering in Emacs</h3><p class=" text-justify">Completion in Emacs is a complex subject matter and one soused in bike shedding and personal opinion. So I’ve kept things open and made it work with <code>completing-read</code> – well, specifically <code>completing-read-multiple</code> so you can pick multiple items.</p><p class=" text-justify">If you’re unsure how that fits into <em>your</em> completion framework, then my article on <a class=" article-link" href="https://www.masteringemacs.org/article/understanding-minibuffer-completion">understanding Minibuffer Completion</a> is a good place to start. If you want IDO to work with it, you’ll have to tweak the code yourself. Luckily I have <a class=" article-link" href="https://www.masteringemacs.org/article/find-files-faster-recent-files-package">an example here</a> to get you started.</p><p class=" text-justify">I’ve also made it work out of the box with Helm which, as we all know, is awesome. Helm in particular is perfect for this as it comes with great fuzzy matching, multiple selection <em>and</em> it’s easy to add custom actions like returning matches to the shell <em>and</em> opening them as files in Emacs, for example.</p><p class=" text-justify">There’s three parts: two completion mechanisms and a generic wrapper that turns lists of candidates into usable output.</p><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defun</span><span class="fu"> ezf-default </span>(filename)
  <span class="st">"EZF completion with your default completion system."</span>
  (completing-read-multiple
   <span class="st">"Pick a Candidate: "</span>
   (with-temp-buffer
     (insert-file-contents-literally filename <span class="kw">nil</span>)
     (string-lines (buffer-string) <span class="kw">t</span>))))</code></pre><p class=" text-justify"><code>completing-read-multiple</code> takes a prompt and a list of strings. And that’s all you need to get Emacs’s completion system to work. I create a temporary buffer to hold the file contents before it’s split up into lines. If you want NULL-separated output, this is the place to change it.</p><p class=" text-justify">If you’re wondering why I’m using a buffer, you should read my article <a class=" article-link" href="https://www.masteringemacs.org/article/why-emacs-has-buffers">Why Emacs has Buffers</a>.</p><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defun</span><span class="fu"> ezf-helm </span>(filename)
  <span class="st">"EZF completion with `helm'."</span>
  <span class="co">;; Uncomment if you want Helm to full screen.</span>
  <span class="co">;; (helm-set-local-variable 'helm-full-frame t)</span>
  (helm :sources
        (helm-build-in-file-source <span class="st">"EZF Completion"</span> filename
          :action (<span class="kw">lambda</span> (_) (helm-marked-candidates)))))</code></pre><p class=" text-justify">For Helm the solution is similar. I’m using Helm’s ability to build candidates directly from a file. If you want to add more than one action then I recommend you use <code>helm-make-actions</code> to build the alist.</p><p class=" text-justify">Now for the generic wrapper. Its job is to take a list of strings you picked from a candidate function and turn it into something the shell can properly read. If you specified <code>-f</code> to <code>ezf</code> then it’ll also split the string and only use the field index you chose.</p><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span class="co">;; If you start Emacs's server some other way, you can remove this.</span>
(server-start)

(<span class="kw">defvar</span><span class="fu"> ezf-separators </span><span class="st">" "</span>
  <span class="st">"Regexp of separators `ezf' should use to split a line."</span>)

(<span class="kw">defun</span><span class="fu"> ezf </span>(filename &amp;optional field completing-fn)
  <span class="st">"Wrapper that calls COMPLETION-FN with FILENAME.</span>

<span class="st">Optionally split each line of string by `ezf-separators' if FIELD</span>
<span class="st">is non-nil and return FIELD.</span>

<span class="st">If COMPLETING-FN is nil default to `ezf-default'."</span>
  (when-let (candidates (<span class="kw">funcall</span> (<span class="kw">or</span> completing-fn 'ezf-default) filename))
    (mapconcat (<span class="kw">lambda</span> (candidate)
                 (shell-quote-argument
                  (<span class="kw">if</span> field
                      (<span class="kw">nth</span> (<span class="kw">1-</span> field) (split-string candidate ezf-separators <span class="kw">t</span> <span class="st">" "</span>))
                    candidate)))
               candidates
               <span class="st">" "</span>)))</code></pre><p class=" text-justify">Here the goal is simply to take a <code>filename</code> containing our candidates; an optional <code>completing-fn</code>, as set by passing <code>-c</code> to <code>ezf</code>; and an optional <code>field</code> index.</p><p class=" text-justify"><code>ezf-separators</code> is a regular expression to split each line by. So if you want NULL-delimited support then you can easily add that and a switch to go along with it.</p><p class=" text-justify">Because we’re taking unsanitized candidates and passing them through our completion system, it’s good form to ensure the filtered candidates are properly escaped when we hand them back to the shell. That’s what <code>shell-quote-argument</code> does. <code>mapconcat</code> merely ensures the quoted candidates are space-separated as that’s what shells expect. (And if you want NULL separation you should change this also.)</p><p class=" text-justify">Because the last value is by convention the value that is returned from a function in Lisp, we know that the output of <code>emacsclient</code> is the result of the <code>mapconcat</code> form if we selected any matches, and <code>nil</code> otherwise.</p><p class=" text-justify">With all this in place it’s time to test it:</p><figure>
   <img alt="fuzzy matching with ezf, the Emacs fuzzy finder" class=" center-block" src="https://www.masteringemacs.org/static/uploads/ezf-default.svg" />
Fuzzy matching dictionary words with Emacs and <code>ezf</code>
</figure><p class=" text-justify">Yep. Looks good.</p><p class=" text-justify">This tool is able to do most of the things you’d use <code>fzf</code> for, and all from within the comfort of your Emacs. It’ll work just fine in Eshell also if you don’t push it too hard. Eshell’s support for pipes and redirection is not as good as regular shells, but with a little bit of work it could be made to work there too, with or without the bash script. And of course you can use it from Terminals also: the ones you run from inside Emacs, and external ones also.</p><h2 id="example-use-cases">Example Use Cases</h2><p class=" text-justify">Here’s a few examples of how you can use the tool. It goes without saying that it’s a bit threadbare compared to <code>fzf</code>, but I think it’s easy enough to extend to suit your own needs. This is also a great way to get your hands dirty with elisp if you have never done any before.</p><p class=" text-justify">I’m going to point out that <code>M-x helm-locate</code> already does this, but you can use GNU <code>locate</code> to track down files matching a regex pattern and then open them in <code>emacsclient</code>:</p><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">emacsclient</span> <span class="ot">$(</span><span class="kw">locate</span> -r <span class="st">'[.]py$'</span> <span class="kw">|</span> <span class="kw">ezf</span><span class="ot">)</span></code></pre><p class=" text-justify">GNU <code>locate</code> works by querying a database that updates whenever you call <code>updatedb</code>. It’s probably the one of fastest cached file searchers available today. You can have multiple databases with different configurations (one for your home directory and another for the whole file system) to further speed it up. I highly recommend you look into using it if you regularly sweep your file system looking for files.</p><p class=" text-justify">Finding and installing packages with <code>apt-get</code> and <code>apt-cache</code>:</p><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">apt-get</span> install <span class="ot">$(</span><span class="kw">apt-cache</span> search <span class="kw">&lt;</span>term<span class="kw">&gt;</span> <span class="kw">|</span> <span class="kw">ezf</span> -f 1<span class="ot">)</span></code></pre><p class=" text-justify">Change directories. Try playing around with the arguments to <code>find</code>, or use something simpler like <code>ls</code>:</p><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cd</span> <span class="ot">$(</span><span class="kw">find</span> . -maxdepth 3 -type d <span class="kw">|</span> <span class="kw">ezf</span><span class="ot">)</span></code></pre><h2 id="next-steps">Next Steps</h2><p class=" text-justify">I think this is a pretty good example of how you can combine the power of Emacs and a little bit of gnarly shell script magic. And this is really just the beginning. You can take the shell script and hook it up to all manner of crazy Emacs stuff: <code>M-x dired</code>; sending stuff to a buffer for editing; and more.</p><p class=" text-justify">You can also find it on Github here: <a class=" article-link" href="https://github.com/mickeynp/ezf">EZF</a>.</p>