<!-- SC_OFF --><div class="md"><h1>Prologue</h1> <p>I tried WSL2 and while it is fast, there are some problems:</p> <ul> <li>WSL2 cannot not modify Windows NAS drives, even if you mount. A deal breaker for me.</li> <li>The Emacs GUI can&#39;t be repositioned using Windows hotkeys like native windows.</li> </ul> <p>I tried the pre-compiled Emacs on Windows, but it is slower than WSL2. Typing latency is not as good. Trying this sample benchmark, with pre-compiled Emacs, it took 6-7 seconds to finish. With my compiled Emacs, it took 2.6 seconds.</p> <p>``` (defun fibonacci(n) (if (&lt;= n 1) n (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))</p> <p>(setq native-comp-speed 3) (native-compile #&#39;fibonacci) (let ((time (current-time))) (fibonacci 40) (message &quot;%.06f&quot; (float-time (time-since time))))</p> <p>```</p> <p><a href="https://www.reddit.com/r/emacs/comments/juo9ru/emacs_lisp_is_at_least_6_times_slower_than_python/">In this thread</a>, someone reported 11 second with native comp!</p> <p>Another benchmark: I opend a file with a <strong>10MB long line</strong>, and Emacs can easily navigate without lag, as fast as Windows Notepad. Meanwhile, opening it with <code>vi</code> in Git bash was unbearably slow, even freezes. Here is the demo file: <a href="https://www.mediafire.com/file/7fx6dp3ss9cvif8/out.txt/file">https://www.mediafire.com/file/7fx6dp3ss9cvif8/out.txt/file</a></p> <p>Here is the demo of my Emacs operating that file: <a href="https://youtu.be/1yHmGpix-bE">https://youtu.be/1yHmGpix-bE</a></p> <p>Everything is much more smoother and responsive (the official pre-compiled Emacs is fast with native compile, but I want to get the same experience as in WSL2 or Linux).</p> <h1>How?</h1> <p>You can follow this guide to compile your Emacs: <a href="https://readingworldmagazine.com/emacs/2022-02-24-compiling-emacs-29-from-source-on-windows/">https://readingworldmagazine.com/emacs/2022-02-24-compiling-emacs-29-from-source-on-windows/</a></p> <p>At step 4, pasting the huge line of package installation can somehow make <code>pacman</code> stop installing packages. Instead, I broken down the dependencies into multiple <code>pacman</code> lines that can be copied and pasted without fail:</p> <p>``` pacman -S autoconf autogen automake automake-wrapper diffutils git guile libgc libguile libltdl libunistring make mingw-w64-x86_64-binutils</p> <p>pacman -S mingw-w64-x86_64-bzip2 mingw-w64-x86_64-cairo mingw-w64-x86_64-crt-git mingw-w64-x86_64-dbus mingw-w64-x86_64-expat</p> <p>pacman -S mingw-w64-x86_64-glib2 mingw-w64-x86_64-gmp mingw-w64-x86_64-gnutls mingw-w64-x86_64-harfbuzz mingw-w64-x86_64-headers-git mingw-w64-x86_64-imagemagick mingw-w64-x86_64-isl mingw-w64-x86_64-libffi mingw-w64-x86_64-libgccjit</p> <p>pacman -S mingw-w64-x86_64-libiconv mingw-w64-x86_64-libjpeg-turbo mingw-w64-x86_64-libpng mingw-w64-x86_64-librsvg mingw-w64-x86_64-libtiff mingw-w64-x86_64-libwinpthread-git mingw-w64-x86_64-libxml2</p> <p>pacman -S mingw-w64-x86_64-mpc mingw-w64-x86_64-mpfr mingw-w64-x86_64-pango mingw-w64-x86_64-pixman mingw-w64-x86_64-winpthreads mingw-w64-x86_64-xpm-nox mingw-w64-x86_64-lcms2 mingw-w64-x86_64-xz mingw-w64-x86_64-zlib tar wget</p> <p>pacman -S texinfo</p> <p>pacman -S pkg-config</p> <p>pacman -S mingw-w64-x86_64-jansson</p> <p>pacman -S mingw-w64-x86_64-tree-sitter ```</p> <p>At step 9 when running <code>./configure</code>, you can use mine:</p> <p><code> ./configure --prefix=/c/emacs --without-pop --without-imagemagick --without-compress-install -without-dbus --with-gnutls --with-json --with-tree-sitter \ --without-gconf --with-rsvg --without-gsettings --with-mailutils \ --with-native-compilation --with-modules --with-xml2 --with-wide-int \ CFLAGS=&quot;-O3 -fno-math-errno -funsafe-math-optimizations -fno-finite-math-only -fno-trapping-math \ -freciprocal-math -fno-rounding-math -fno-signaling-nans \ -fassociative-math -fno-signed-zeros -frename-registers -funroll-loops \ -mtune=native -march=native -fomit-frame-pointer \ -fallow-store-data-races -fno-semantic-interposition -floop-parallelize-all -ftree-parallelize-loops=4&quot; </code></p> <p>Change <code>--prefix=</code> value to where you want to install. You can read a more detailed explanation of the GCC flags here: <a href="https://simonbyrne.github.io/notes/fastmath/">https://simonbyrne.github.io/notes/fastmath/</a></p> <p>After building and run <code>make install, check the directory where you assign to the</code>prefix=<code>flag. In the above example, your build binaries should be at</code>C:\emacs\bin<code>. Open the folder and click</code>runemacs.exe`</p> <p>Now, you need to compile all the built-in Elisp libraries:</p> <ul> <li>First, check the variable <code>native-comp-eln-load-path</code>.</li> <li>Then, run this Elisp code to compile every built-in <code>.el</code> file to <code>.eln</code> for that native experience:</li> </ul> <p><code> (setq native-comp-speed 3) ;; maximum native Elisp speed! (native-compile-async &quot;C:\emacs\share\emacs\29.0.90&quot; &#39;recursively) </code></p> <p>You should put <code>(setq native-comp-speed 3)</code> at the beginning of your <code>init.el</code> file, so any package you download will be maximally optimized.</p> <p>Since Emacs 29 comes with <code>treesit</code> package, you should run the command <code>treesit-install-language-grammar</code> to parse your buffer even faster, making your Emacs even faster!</p> <h1>Hardware</h1> <p>With the fast advancement of CPU in recent year, it&#39;s incredibly cheap to buy a budget with fast CPU cores to speed up your Emacs. For $500, you can build a budget zen 3 PC (Ryzen 5000 series) or a budget 12th/13th gen Intel CPU. Faster CPU will drastically improve Emacs snappiness and input latency. Also, at least get an SSD drive to put your Windows and Emacs there.</p> <p>Going further, you can review and get a mech keyboard with low latency, e.g. sub-5ms. You can read the reviews on Rtings.</p> <p>Then, get a high refresh rate monitor, e.g. 144 Hz to see your buffer update faster! Now you can get a 1440p with the new fast IPS panel (0.5ms response time) around $300. Full HD is even cheaper. If you have money, get an OLED monitor.</p> <h1>Software</h1> <p>Windows is getting bloater as CPU getting faster. So, you should consider tune your Windows to make it run faster. For example:</p> <ul> <li><p><a href="https://www.askvg.com/windows-10-fix-too-many-svchost-exe-service-host-process-running-in-task-manager/">you can reduce the number of svhost processes</a></p></li> <li><p>Use <a href="https://wpd.app/">Windows Privacy Dashboard</a> to block telemetry.</p></li> <li><p><a href="https://www.howtogeek.com/368781/how-to-enable-ultimate-performance-power-plan-in-windows-10/">Enable Ultimate Performance power plan</a></p></li> <li><p>If you are on Windows 11, <a href="https://www.tomshardware.com/how-to/disable-vbs-windows-11">disable VBS</a></p></li> <li><p>Run as Admin mode, <a href="https://www.grc.com/inspectre.htm">disable Spectre and Meltdown protection</a>. Spectre and Meltdown software mitigations <a href="https://www.phoronix.com/review/linux50-spectre-meltdown">can significantly reduce your CPU performance</a>, along with VBS on Windows 11.</p></li> </ul> <p>There are more tricks, but the above are easy ones that you can do with a few clicks. You can check your system latency with <a href="https://www.resplendence.com/latencymon">Latency Mon</a>, before and after the changes.</p> <p>I know that&#39;s a lot of effort if you are first time into compiling stuffs. Hopefully you can endure or enjoy the process and get the best out of Emacs! Please share some other tips to speed up.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/tuhdo"> /u/tuhdo </a> <br/> <span><a href="https://www.reddit.com/r/emacs/comments/131354i/guide_compile_your_own_emacs_to_make_it_really/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/emacs/comments/131354i/guide_compile_your_own_emacs_to_make_it_really/">[comments]</a></span>