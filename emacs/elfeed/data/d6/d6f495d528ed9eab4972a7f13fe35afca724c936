<!-- SC_OFF --><div class="md"><p>Here&#39;s another example of &quot;what&#39;s old is new again&quot; - remember how a long time ago, you interacted with a modem by giving it textual commands, and then it connected you to distant machines, which you also spoke to in text, and when you wanted to send and receive binary files, you had to encode those as text too?</p> <p>Well, that still works, and the commands needed to encode/decode it are installed by default pretty much everywhere, so that means you can...</p> <ul> <li>Suppose there&#39;s some system you connect to through a VPN and then two jump boxes. You&#39;ve ssh&#39;d all the way there, but were lazy and didn&#39;t bother port-forwarding (if that&#39;s even allowed), and now you need to get a copy of some config file. Instead of copy/pasting it a bit at a time, or trying to make your scrollback buffer and text wrapping cooperate (and still convert tabs to weird numbers of spaces...), you can:</li> </ul> <p>on the sending side: <code>cat file.conf | base64</code></p> <p>Now you don&#39;t have to worry about formatting at all*! Just copy all the base64 text as a block, and on the receive side: <code>base64 -d &gt; file.conf_from_remote</code></p> <p>now paste the text, press enter, then ctrl+d when you&#39;re done, and you have a binary-identical copy of the file on your local system, regardless of how many spaces, newlines, and messed up terminal wrapping you copied.</p> <ul> <li><p>* The caveat: sometimes you&#39;ll run into this on decode: &quot;base64: invalid input&quot;. In that case, try <code>base64 -di</code> as the decode command - for some weird reason, certain versions of the base64 utility can&#39;t even decode their own input by default, because they decide to insert newlines on encode, but barf immediately on any non-base64 character on decode...including newlines. I have seen this behaviour primarily on old Gentoo boxes, Solaris, and ancient versions of CentOS and Red Hat.</p></li> <li><p>Doesn&#39;t even have to be a remote system of course. I use this sometimes when I can&#39;t be arsed to deal with <code>sudo</code>/<code>chmod</code>/<code>chown</code> when copying a file between sessions running as different restricted users, or across a chroot, container, VM, etc.</p></li> </ul> <h5>Next trick:</h5> <p>Suppose you&#39;re editing a file locally and you want to copy a piece of a remote file, and it&#39;s very important to exactly preserve the indenting and whitespace (because it&#39;s python, yaml, or you&#39;ve forgotten about &quot;:set paste&quot; in vim and internalised the notion that auto-indent is forever...but &quot;set paste&quot; doesn&#39;t help you with tabs not surviving a terminal display anyway). You can do this:</p> <p>shift+V to go to visual select line mode; select the block you want</p> <p>type <code>:! base64</code> &lt;enter&gt;</p> <p>copy &amp; paste the block into your other vim, then select the base64 text</p> <p>type <code>:! base64 -d</code> &lt;enter&gt;</p> <p>and there it is, in all its tabular/nonprinting/emoji/16-bit-big-endian-unicode-because-why-not glory. (You&#39;ll want to undo the encode step on the source system, obviously.)</p> <p>Don&#39;t believe me that it&#39;s 100% binary identical? Select the text blocks on both sides and check:</p> <p><code>:! md5sum</code></p> <p>[<strong>Edit</strong>: Important note about md5sum - it is only useful as a casual check against random errors nowadays, it is <strong>not</strong> a secure or cryptographic hash by any means. Think of it like a &quot;deluxe crc32&quot;; using it in interactive contexts like this is fine, but do not use it in scripts, etc.]</p> <p>(Incidentally, if the block of text you want is really small or your local one is very similar already, you can skip the base64 and just edit it manually and just use md5sum to confirm you got it right.)</p> <h3>If your file or block of text is longer than a screenful</h3> <p>Pipe it to gzip first:</p> <p><code>cat file.txt | gzip -9 | base64</code></p> <p><code>base64 -d | gunzip &gt; file.txt_copy</code></p> <p>(For very small inputs, gzip often produces slightly fewer bytes than xz and even zstd, plus it&#39;s available practically everywhere.)</p> <p>You can also scrunch down the base64 a little more by setting the line-width to unlimited (<code>base64 -w 0</code>), but be aware that:</p> <ul> <li>Some implementations are buggy when it comes to very long lines (the opposite problem of the earlier caveat).</li> <li>Even if the base64 command is OK with it, sometimes the terminal program isn&#39;t.</li> <li>4096 bytes per line is a common threshold at which something barfs.</li> <li>It can make the copy/pasting more error-prone, as it&#39;s easier to miss a single character somewhere (and if you accidentally paste it in the wrong place, it makes more of a mess... on the other hand, at least your shell history will only have <em>one</em> bogus entry on accidental paste instead of 150. Ask me how many times I&#39;ve seen &quot;<code>-bash: H4sIAAAAAAACAxXJQQ6AIAxE0b2nmJu49RoVxmgiLaFFw+2V3X/5m71IooiTUAakWNeAHaBGszpm: No such file or directory -bash: ztn1etic2Iki7r/ugczUKM68Lh893ENmSgAAAA==: No such file or directory</code>&quot; :P).</li> </ul> <h3>Important note for sysadmins and especially network people</h3> <p>I mentioned serial connections at the beginning of this. I cannot believe how many times I&#39;ve see people laboriously copy a few lines at a time, paste them into their terminal window, wait (9600 8 N 1 only goes so fast, y&#39;all...), copy a few more... and then cross their fingers and pray that no characters got lost, and none of the accidental extra whitespace will matter, when restoring a switch configuration.</p> <p>The civilised way to do this is to be in shell mode on the switch instead of config mode (and if your switches don&#39;t have a basic Linux-like shell, consider switching to some that do), and do a base64 copy/paste as described, and then compare checksums. Especially if gzip is available on the switch, this is much, much faster and more reliable, and then you can do a local &quot;load config&quot; and not have any terminal issues in config mode.</p> <p>(Some may argue that transferring over tftp or some variant of DHCP-mediated auto-provision is &quot;more civilised&quot;, but 1, you&#39;re in this situation because your network is buggered so that might not be an option, and 2, I bet if you held a race, the base64 person would be done long before the tftp person has even finished the &quot;how the crap do I get this server listening again?! why is it not serving files?!&quot; stage of cursing, never mind the &quot;I fat-fingered a subnet mask&quot; or &quot;oh yeah, we block tftp at the firewall for this subnet now, don&#39;t we?&quot; stages of cursing.)</p> <h3>If your remote system is weird and doesn&#39;t have a base64 command</h3> <p>Good chance it still does and it&#39;s just part of something else. Hint: openssl has it built in (<code>openssl base64</code> is equivalent to <code>base64</code>) if that&#39;s available (e.g. Juniper switches I think). <code>openssl md5</code> also works if you&#39;re missing md5sum, but also try just <code>md5</code>, because it&#39;s called that on some unixes (I want to say Juniper switches again? or Mac OS?).</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/will_try_not_to"> /u/will_try_not_to </a> <br/> <span><a href="https://www.reddit.com/r/linux/comments/131xi1f/stupid_linux_tricks_use_base64_to_perfectly/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/linux/comments/131xi1f/stupid_linux_tricks_use_base64_to_perfectly/">[comments]</a></span>